# Отчет по лабораторной работе №1
## Работа со списками и реляционным представлением данных
## по курсу "Логическое программирование"

### студент: Петросян В.А.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |               |


## Введение

Любой список в Прологе можно представить как двоичное дерево, в листьях которого находятся элементы списка или пустой список . Он либо пуст, либо состоит из 2х частей: головы и хвоста, который сам является списком . Элементом списка может быть любой объект .

Например список [11,'hi',13,14] можно представить так:
[11,'hi',13,14] - корень , 11 - левое поддерево , ['hi',13,14] - правое поддерево
и так далее до 14 и [].

Списки в прологе по сравнению с структурами данных в императивных языках имеют следющие плюсы:
1. Неограниченную вложенность
2. В списке одновременно можно разместить данные разного типа.
3. Неограниченную длину

Основой работы со списком является рекурсивное разделение его на голову и хвост,за счет чего мы можем по нему перемещаться.
В императивных языках всё иначе . Навигация происходит либо с помощью итераторов либо при обращении по индексу.

## Задание 1.1: Предикат обработки списка

`count_member(X,List,Number)` - подсчитывает число вхождений символа X в списке List.

Примеры использования:
```prolog
| ?- count_member(1,[11,1,1,2,3,4],X).
X = 2
yes
| ?- count_member(4,[11,1,1,2,3,4],X).
X = 1
yes
```

Реализация без использования стандартных предикатов :
```prolog
count_member(_,[],0):-!.
count_member(X,[X|List],Number):-
	count_member(X,List,N1),
	Number is N1 + 1,!.
count_member(X,[_|List],Number):-
	count_member(X,List,Number),!.
```
Если символ X совпадает с головой списка , то счетчик вхождений увеличивается .
Реализация с использованием стандартных предикатов :
```prolog
selct(X,[X|Xs],Xs).
selct(X,[Y|Xs],[Y|Zs]):-selct(X,Xs,Zs).

count_member_2(X,List,Number):-
	member(X,List),
	selct(X,List,Rlist),
	count_member(X,Rlist,N1),
	Number is N1 + 1,!.
```
При вхождении элемента X в список List , он удаляется из списка , при этом счетчик вхождений увеличивается.
## Задание 1.2: Предикат обработки числового списка

`count_max(List,Max)` - Находит позицию в списке первого отрицательного элемента.

Примеры использования:
```prolog
| ?- count_max([1,2,3,-5,3],X).
X = 3
yes
| ?- count_max([1,2,3,5,3],X).
X = 5
yes
```

Реализация без использования стандартных предикатов :
```prolog
count_max([Y|List],X):-
	get_max([Y|List],Y,X),!.
get_max([],M,M):-!.
	get_max([L|List],M,X):-
	L>M,
	get_max(List,L,X);
	get_max(List,M,X).
```
В каждом этапе рекурсии происходит сопоставление максимального элемента и головы списка , в случае , если голова > максимального элемента , то макс элемент = голова , иначе максимальный элемент не меняется.

Реализация с использованием стандартных предикатов :
```prolog
count_max_2(List,X):-
	sort(List,Result),
	reverse(Result,[X|_]).
```
Сначала сортируем список , затем берем голову его реверса .

## Задание 2: Реляционное представление данных
Плюсы реляционного представления данных:
1. Просто хранить информацию.
2. Обработка данных с помощью пролога проста , так как он обрабатывает их как списки.

Минусы:
1. Не все представления удобны для обработки.

В моем представлении факты записывались вот так: grade(Group,Subject,Student,Mark).
C помощью встроенного предиката findall/3 легко найти , например, список студентов данной группы.
Недостатков в таком представлении не нашел.Быть может только один:
иногда надо было удалять повторяющиеся элементы из списка.

   Вариант 2
    - Напечатать средний балл для каждого предмета
    - Для каждой группы, найти количество не сдавших студентов 
    - Найти количество не сдавших студентов для каждого из предметов

Вариант реляционного представления : two.pl

Задание 1:
`average_mark(Subject,X).` - выводит средний бал студентов сдававших данный предмет.
```prolog
| ?- average_mark('Informatika',X).
X = 3.9285714285714284
yes
| ?- average_mark('Logicheskoe programmirovanie',X).
X = 3.9642857142857144
yes
```
Листинг:
```prolog
get_average_mark([],0).
get_average_mark([M|Marks],Sum):-
	get_average_mark(Marks,S),
	Sum is M + S.
average_mark(Subject,X):-
	findall(Mark,grade(_,_,Subject,Mark),Marks),
	get_average_mark(Marks,M),
	length(Marks,Len),
	X is M / Len.
```
Сначала находим все оценки по данному предмету , потом считаем их сумму оценок из списка оценок , затем делим результат на длину списка оценок.
Задание 2:
`dont_pass(Group,X)` - выводит количество не сдавших студентов , для данной группы.
```prolog
| ?- dont_pass(104,X).
X = 2
yes
| ?- dont_pass(101,X).
X = 2
yes
```
Листинг:
```prolog
no_repeats([], []):-!.
no_repeats([X|Xs], Ys):-
	member(X, Xs),!,
	no_repeats(Xs, Ys).
no_repeats([X|Xs], [X|Ys]):-
	no_repeats(Xs, Ys).
	
dont_pass(Group,X):-
	findall(Student,grade(Group,Student,_,2),Students),
	no_repeats(Students,Studs),
	length(Studs,X).
```
Сначала находим всех студентов данной группы , которые не сдали тот или иной предмет , затем удаляем повторения в получившемся списке , затем считаем длину списка , что будет ответом
Задание 3:
`max_mark(Group,X).` -  выводит количество не сдавших студентов , для данного предмета.
```prolog
| ?- dont_pass_subj('Informatika',X).
X = 2
yes
| ?- dont_pass_subj('Logicheskoe programmirovanie',X).
X = 2
yes
```
Листинг:
```prolog
dont_pass_subj(Subject,X):-
	findall(Student,grade(_,Student,Subject,2),Students),
	length(Students,X).
```
Сначала находим всех студентов с двойкой по данному предмету , затем вычисляем длину получившегося списка .

## Выводы

Считаю , что пролог - очень интересный язык . Он эффективен при работе с символьными структурыми данных . Сам ищет данные . Для написания программ из первой и второй части на языках императивного типа понадобилось бы намного больше ненужной работы .

При выполнении данной работы нужно было понять , как "думает пролог" , когда выполняет задачи . Для этого пришлось покопаться в интеренете и поискать решение. Нашел видеоролик про трассировку trace с помощью которой отлаживал программу. Это очень помогает , так как самому прокрутить программу в поисках ошибки - трудно .






